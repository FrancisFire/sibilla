/**
 * generated by Xtext 2.17.0
 */
package quasylab.sibilla.lang.pm.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import com.google.inject.Inject;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.function.Function;
import java.util.function.Predicate;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.util.IResourceScopeCache;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;
import quasylab.sibilla.lang.pm.model.AndExpression;
import quasylab.sibilla.lang.pm.model.CallExpression;
import quasylab.sibilla.lang.pm.model.Constant;
import quasylab.sibilla.lang.pm.model.Expression;
import quasylab.sibilla.lang.pm.model.FractionOf;
import quasylab.sibilla.lang.pm.model.IfThenElseExpression;
import quasylab.sibilla.lang.pm.model.Macro;
import quasylab.sibilla.lang.pm.model.MaxExpression;
import quasylab.sibilla.lang.pm.model.MinExpression;
import quasylab.sibilla.lang.pm.model.ModelPackage;
import quasylab.sibilla.lang.pm.model.ModuloExpression;
import quasylab.sibilla.lang.pm.model.MulDivExpression;
import quasylab.sibilla.lang.pm.model.Multiplicity;
import quasylab.sibilla.lang.pm.model.NegationExpression;
import quasylab.sibilla.lang.pm.model.NotExpression;
import quasylab.sibilla.lang.pm.model.NumberOf;
import quasylab.sibilla.lang.pm.model.OrExpression;
import quasylab.sibilla.lang.pm.model.ReferenceableElement;
import quasylab.sibilla.lang.pm.model.RelationExpression;
import quasylab.sibilla.lang.pm.model.Rule;
import quasylab.sibilla.lang.pm.model.SumDiffExpression;
import quasylab.sibilla.lang.pm.validation.AbstractModelValidator;
import quasylab.sibilla.lang.pm.validation.ExpressionType;
import quasylab.sibilla.lang.pm.validation.ExpressionTypeInference;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ModelValidator extends AbstractModelValidator {
  protected static final String ISSUE_CODE_PREFIX = "quasylab.sibilla.lang.pm.";
  
  public static final String RECURSIVE_DECLARATION = (ModelValidator.ISSUE_CODE_PREFIX + "RecursiveDeclaration");
  
  public static final String TYPE_MISMATCH = (ModelValidator.ISSUE_CODE_PREFIX + "TypeMismatch");
  
  public static final String INCOMPATIBLE_TYPES = (ModelValidator.ISSUE_CODE_PREFIX + "IncompatibleType");
  
  public static final String ILLEGAL_POPULATION_EXPRESSION = (ModelValidator.ISSUE_CODE_PREFIX + "IllegalPopulationExpression");
  
  public static final String ILLEGAL_POPULATION_EXPRESSION_MESSAGE = "Illegal use of population expressions!";
  
  @Inject
  @Extension
  private ExpressionTypeInference _expressionTypeInference;
  
  @Inject
  private IResourceScopeCache cache = IResourceScopeCache.NullImpl.INSTANCE;
  
  @Check
  public void checkBooleanInOr(final OrExpression e) {
    this.checkExpectedBoolean(e.getLeft(), ModelPackage.eINSTANCE.getOrExpression_Left());
    this.checkExpectedBoolean(e.getRight(), ModelPackage.eINSTANCE.getOrExpression_Right());
  }
  
  @Check
  public void checkBooleanInAnd(final AndExpression e) {
    this.checkExpectedBoolean(e.getLeft(), ModelPackage.eINSTANCE.getAndExpression_Left());
    this.checkExpectedBoolean(e.getRight(), ModelPackage.eINSTANCE.getAndExpression_Right());
  }
  
  @Check
  public void checkNumbersInRelations(final RelationExpression e) {
    this.checkExpectedNumber(e.getLeft(), ModelPackage.eINSTANCE.getRelationExpression_Left());
    this.checkExpectedNumber(e.getRight(), ModelPackage.eINSTANCE.getRelationExpression_Right());
  }
  
  @Check
  public void checkIntegerInModulo(final ModuloExpression e) {
    this.checkExpectedInteger(e.getLeft(), ModelPackage.eINSTANCE.getModuloExpression_Left());
    this.checkExpectedInteger(e.getRight(), ModelPackage.eINSTANCE.getModuloExpression_Right());
  }
  
  @Check
  public void checkNumbersInMulDiv(final MulDivExpression e) {
    this.checkExpectedNumber(e.getLeft(), ModelPackage.eINSTANCE.getMulDivExpression_Left());
    this.checkExpectedNumber(e.getRight(), ModelPackage.eINSTANCE.getMulDivExpression_Right());
  }
  
  @Check
  public void checkNumbersInSumDiff(final SumDiffExpression e) {
    this.checkExpectedNumber(e.getLeft(), ModelPackage.eINSTANCE.getSumDiffExpression_Left());
    this.checkExpectedNumber(e.getRight(), ModelPackage.eINSTANCE.getSumDiffExpression_Right());
  }
  
  @Check
  public void checkBooleanInNot(final NotExpression e) {
    this.checkExpectedBoolean(e.getArgument(), ModelPackage.eINSTANCE.getNotExpression_Argument());
  }
  
  @Check
  public void checkIfThenElseExpression(final IfThenElseExpression e) {
    this.checkExpectedBoolean(e.getGuard(), ModelPackage.eINSTANCE.getIfThenElseExpression_Guard());
    ExpressionType _elvis = null;
    Expression _ifBranch = e.getIfBranch();
    ExpressionType _inferType = null;
    if (_ifBranch!=null) {
      _inferType=this._expressionTypeInference.inferType(_ifBranch);
    }
    if (_inferType != null) {
      _elvis = _inferType;
    } else {
      _elvis = ExpressionType.ERROR;
    }
    final ExpressionType tLeft = _elvis;
    boolean _notEquals = (!Objects.equal(tLeft, ExpressionType.ERROR));
    if (_notEquals) {
      ExpressionType _elvis_1 = null;
      Expression _elseBranch = e.getElseBranch();
      ExpressionType _inferType_1 = null;
      if (_elseBranch!=null) {
        _inferType_1=this._expressionTypeInference.inferType(_elseBranch);
      }
      if (_inferType_1 != null) {
        _elvis_1 = _inferType_1;
      } else {
        _elvis_1 = ExpressionType.ERROR;
      }
      final ExpressionType tRight = _elvis_1;
      if (((!Objects.equal(tRight, ExpressionType.ERROR)) && Objects.equal(ExpressionTypeInference.combine(tLeft, tRight), ExpressionType.ERROR))) {
        this.error(ModelValidator.incompatibleTypesMessage(tLeft, tRight), ModelPackage.eINSTANCE.getIfThenElseExpression_ElseBranch(), ModelValidator.INCOMPATIBLE_TYPES);
      }
    }
  }
  
  @Check
  public void checkNumberInNegation(final NegationExpression e) {
    this.checkExpectedNumber(e.getArgument(), ModelPackage.eINSTANCE.getNegationExpression_Argument());
  }
  
  @Check
  public void checkNumberInMin(final MinExpression e) {
    final Procedure2<Expression, Integer> _function = (Expression arg, Integer i) -> {
      this.checkExpectedNumber(arg, ModelPackage.eINSTANCE.getMinExpression_Args(), (i).intValue());
    };
    IterableExtensions.<Expression>forEach(e.getArgs(), _function);
  }
  
  @Check
  public void checkNumberInMin(final MaxExpression e) {
    final Procedure2<Expression, Integer> _function = (Expression arg, Integer i) -> {
      this.checkExpectedNumber(arg, ModelPackage.eINSTANCE.getMaxExpression_Args(), (i).intValue());
    };
    IterableExtensions.<Expression>forEach(e.getArgs(), _function);
  }
  
  @Check
  public void checkGuardRule(final Rule e) {
    Expression _guard = e.getGuard();
    boolean _tripleNotEquals = (_guard != null);
    if (_tripleNotEquals) {
      this.checkExpectedBoolean(e.getGuard(), ModelPackage.eINSTANCE.getRule_Guard());
    }
  }
  
  @Check
  public void checkRateRule(final Rule e) {
    this.checkExpectedNumber(e.getRate(), ModelPackage.eINSTANCE.getRule_Rate());
  }
  
  @Check
  public void checkIntegerMultiplicity(final Multiplicity m) {
    this.checkExpectedInteger(m.getSize(), ModelPackage.eINSTANCE.getMultiplicity_Size());
  }
  
  @Check
  public void checkPopulationFraction(final FractionOf f) {
    boolean _dynamicContext = this.dynamicContext(f);
    boolean _not = (!_dynamicContext);
    if (_not) {
      this.error(ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE, ModelPackage.eINSTANCE.getFractionOf_Agent(), ModelValidator.ILLEGAL_POPULATION_EXPRESSION);
    }
  }
  
  public boolean dynamicContext(final Expression e) {
    boolean _xblockexpression = false;
    {
      final Rule rule = EcoreUtil2.<Rule>getContainerOfType(e, Rule.class);
      final Macro macro = EcoreUtil2.<Macro>getContainerOfType(e, Macro.class);
      _xblockexpression = ((rule != null) || (macro != null));
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkPopulationFraction(final NumberOf f) {
    boolean _dynamicContext = this.dynamicContext(f);
    boolean _not = (!_dynamicContext);
    if (_not) {
      this.error(ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE, ModelPackage.eINSTANCE.getNumberOf_Agent(), ModelValidator.ILLEGAL_POPULATION_EXPRESSION);
    }
  }
  
  @Check
  public void checkCallOfMacro(final CallExpression c) {
    ReferenceableElement _symbol = c.getSymbol();
    if ((_symbol instanceof Macro)) {
      boolean _dynamicContext = this.dynamicContext(c);
      boolean _not = (!_dynamicContext);
      if (_not) {
        this.error(ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE, ModelPackage.eINSTANCE.getCallExpression_Symbol(), ModelValidator.ILLEGAL_POPULATION_EXPRESSION);
      }
    }
  }
  
  @Check
  public void checkNoConstantRecursion(final Constant c) {
    final HashSet<Constant> usedConstants = CollectionLiterals.<Constant>newHashSet();
    final LinkedList<Constant> toVisitConstants = CollectionLiterals.<Constant>newLinkedList();
    final Procedure1<Constant> _function = (Constant it) -> {
      toVisitConstants.add(it);
    };
    IteratorExtensions.<Constant>forEach(this.getAllUsedConstants(c), _function);
    while ((!toVisitConstants.isEmpty())) {
      {
        final Constant c1 = toVisitConstants.poll();
        usedConstants.add(c1);
        final Function1<Constant, Boolean> _function_1 = (Constant it) -> {
          boolean _contains = usedConstants.contains(it);
          return Boolean.valueOf((!_contains));
        };
        final Procedure1<Constant> _function_2 = (Constant it) -> {
          toVisitConstants.add(it);
        };
        IteratorExtensions.<Constant>forEach(IteratorExtensions.<Constant>filter(this.getAllUsedConstants(c1), _function_1), _function_2);
      }
    }
    boolean _contains = usedConstants.contains(c);
    if (_contains) {
      this.error(
        ModelValidator.recursiveDeclarationMessage(c.getName()), 
        ModelPackage.eINSTANCE.getConstant_Value(), 
        ModelValidator.RECURSIVE_DECLARATION);
    }
  }
  
  @Check
  public void checkNoMacroRecursion(final Macro m) {
    final HashSet<Macro> usedConstants = CollectionLiterals.<Macro>newHashSet();
    final LinkedList<Macro> toVisitConstants = CollectionLiterals.<Macro>newLinkedList();
    final Procedure1<Macro> _function = (Macro it) -> {
      toVisitConstants.add(it);
    };
    IteratorExtensions.<Macro>forEach(this.getAllUsedMacros(m), _function);
    while ((!toVisitConstants.isEmpty())) {
      {
        final Macro m1 = toVisitConstants.poll();
        usedConstants.add(m1);
        final Function1<Macro, Boolean> _function_1 = (Macro it) -> {
          boolean _contains = usedConstants.contains(it);
          return Boolean.valueOf((!_contains));
        };
        final Procedure1<Macro> _function_2 = (Macro it) -> {
          toVisitConstants.add(it);
        };
        IteratorExtensions.<Macro>forEach(IteratorExtensions.<Macro>filter(this.getAllUsedMacros(m1), _function_1), _function_2);
      }
    }
    boolean _contains = usedConstants.contains(m);
    if (_contains) {
      this.error(
        ModelValidator.recursiveDeclarationMessage(m.getName()), 
        ModelPackage.eINSTANCE.getMacro_Value(), 
        ModelValidator.RECURSIVE_DECLARATION);
    }
  }
  
  public Iterator<Constant> getAllUsedConstants(final Constant c) {
    final Function1<CallExpression, ReferenceableElement> _function = (CallExpression it) -> {
      return it.getSymbol();
    };
    return Iterators.<Constant>filter(IteratorExtensions.<CallExpression, ReferenceableElement>map(Iterators.<CallExpression>filter(c.eAllContents(), CallExpression.class), _function), Constant.class);
  }
  
  public Iterator<Macro> getAllUsedMacros(final Macro m) {
    final Function1<CallExpression, ReferenceableElement> _function = (CallExpression it) -> {
      return it.getSymbol();
    };
    return Iterators.<Macro>filter(IteratorExtensions.<CallExpression, ReferenceableElement>map(Iterators.<CallExpression>filter(m.eAllContents(), CallExpression.class), _function), Macro.class);
  }
  
  private void checkExpectedBoolean(final Expression e, final EReference reference) {
    this.checkExpectedType(e, ExpressionType.BOOLEAN, reference);
  }
  
  private void checkExpectedInteger(final Expression e, final EReference reference) {
    this.checkExpectedType(e, ExpressionType.INTEGER, reference);
  }
  
  private void checkExpectedDouble(final Expression e, final EReference reference) {
    this.checkExpectedType(e, ExpressionType.DOUBLE, reference);
  }
  
  private void checkExpectedNumber(final Expression e, final EReference reference) {
    final Function<ExpressionType, String> _function = (ExpressionType t) -> {
      return ModelValidator.numberTypeExpected(t);
    };
    final Predicate<ExpressionType> _function_1 = (ExpressionType t) -> {
      return this._expressionTypeInference.isANumberType(t);
    };
    this.checkExpectedType(e, _function, _function_1, reference);
  }
  
  private void checkExpectedNumber(final Expression e, final EReference reference, final int index) {
    final Function<ExpressionType, String> _function = (ExpressionType t) -> {
      return ModelValidator.numberTypeExpected(t);
    };
    final Predicate<ExpressionType> _function_1 = (ExpressionType t) -> {
      return this._expressionTypeInference.isANumberType(t);
    };
    this.checkExpectedType(e, _function, _function_1, reference, index);
  }
  
  private void checkExpectedType(final Expression e, final ExpressionType expectedType, final EReference reference) {
    final Function<ExpressionType, String> _function = (ExpressionType t) -> {
      return ModelValidator.wrongExpectedTypeMessage(expectedType, t);
    };
    final Predicate<ExpressionType> _function_1 = (ExpressionType t) -> {
      return Objects.equal(t, expectedType);
    };
    this.checkExpectedType(e, _function, _function_1, reference);
  }
  
  private void checkExpectedType(final Expression e, final Function<ExpressionType, String> msg, final Predicate<ExpressionType> p, final EReference reference) {
    ExpressionType _inferType = null;
    if (e!=null) {
      _inferType=this._expressionTypeInference.inferType(e);
    }
    final ExpressionType actualType = _inferType;
    if ((((actualType != null) && (!Objects.equal(actualType, ExpressionType.ERROR))) && (!p.test(actualType)))) {
      this.error(msg.apply(actualType), reference, ModelValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkExpectedType(final Expression e, final Function<ExpressionType, String> msg, final Predicate<ExpressionType> p, final EReference reference, final int index) {
    ExpressionType _inferType = null;
    if (e!=null) {
      _inferType=this._expressionTypeInference.inferType(e);
    }
    final ExpressionType actualType = _inferType;
    if ((((actualType != null) && (!Objects.equal(actualType, ExpressionType.ERROR))) && (!p.test(actualType)))) {
      this.error(msg.apply(actualType), reference, index, ModelValidator.TYPE_MISMATCH);
    }
  }
  
  public static String incompatibleTypesMessage(final ExpressionType expected, final ExpressionType actual) {
    return (((("Incompatible types: expected " + expected) + " is ") + actual) + ".");
  }
  
  public static String numberTypeExpected(final ExpressionType actual) {
    return (((((("Expected " + ExpressionType.INTEGER) + " or ") + ExpressionType.DOUBLE) + " but it is ") + actual) + ".");
  }
  
  public static String wrongExpectedTypeMessage(final ExpressionType expected, final ExpressionType actual) {
    return (((("Expected " + expected) + " but it is ") + actual) + ".");
  }
  
  public static String booleanTypeExpected(final ExpressionType actual) {
    return (((("Expected " + ExpressionType.BOOLEAN) + " but it is ") + actual) + ".");
  }
  
  public static String integerTypeExpected(final ExpressionType actual) {
    return (((("Expected " + ExpressionType.INTEGER) + " but it is ") + actual) + ".");
  }
  
  public static String recursiveDeclarationMessage(final String symbol) {
    return (("Cycle in definition of symbol" + symbol) + "!");
  }
}
