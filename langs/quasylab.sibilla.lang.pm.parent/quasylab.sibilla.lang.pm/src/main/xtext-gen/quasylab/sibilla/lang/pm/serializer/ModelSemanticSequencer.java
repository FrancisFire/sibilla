/*
 * generated by Xtext 2.18.0.M3
 */
package quasylab.sibilla.lang.pm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import quasylab.sibilla.lang.pm.model.AndExpression;
import quasylab.sibilla.lang.pm.model.CallExpression;
import quasylab.sibilla.lang.pm.model.Constant;
import quasylab.sibilla.lang.pm.model.DifferenceOperator;
import quasylab.sibilla.lang.pm.model.DisEqualOperator;
import quasylab.sibilla.lang.pm.model.DivisionOperator;
import quasylab.sibilla.lang.pm.model.EqualOperator;
import quasylab.sibilla.lang.pm.model.FalseLiteral;
import quasylab.sibilla.lang.pm.model.FractionOf;
import quasylab.sibilla.lang.pm.model.GreaterOperator;
import quasylab.sibilla.lang.pm.model.GreaterOrEqualOperator;
import quasylab.sibilla.lang.pm.model.IfThenElseExpression;
import quasylab.sibilla.lang.pm.model.LessOperator;
import quasylab.sibilla.lang.pm.model.LessOrEqualOperator;
import quasylab.sibilla.lang.pm.model.Macro;
import quasylab.sibilla.lang.pm.model.MaxExpression;
import quasylab.sibilla.lang.pm.model.Measure;
import quasylab.sibilla.lang.pm.model.MinExpression;
import quasylab.sibilla.lang.pm.model.Model;
import quasylab.sibilla.lang.pm.model.ModelPackage;
import quasylab.sibilla.lang.pm.model.ModuloExpression;
import quasylab.sibilla.lang.pm.model.MulDivExpression;
import quasylab.sibilla.lang.pm.model.MultiplicationOperator;
import quasylab.sibilla.lang.pm.model.Multiplicity;
import quasylab.sibilla.lang.pm.model.NegationExpression;
import quasylab.sibilla.lang.pm.model.NotExpression;
import quasylab.sibilla.lang.pm.model.NumExpression;
import quasylab.sibilla.lang.pm.model.NumberOf;
import quasylab.sibilla.lang.pm.model.OrExpression;
import quasylab.sibilla.lang.pm.model.Population;
import quasylab.sibilla.lang.pm.model.RelationExpression;
import quasylab.sibilla.lang.pm.model.Rule;
import quasylab.sibilla.lang.pm.model.Species;
import quasylab.sibilla.lang.pm.model.SumDiffExpression;
import quasylab.sibilla.lang.pm.model.SumOperator;
import quasylab.sibilla.lang.pm.model.TrueLiteral;
import quasylab.sibilla.lang.pm.model.ZeroDivisionOperator;
import quasylab.sibilla.lang.pm.services.ModelGrammarAccess;

@SuppressWarnings("all")
public class ModelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ModelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ModelPackage.CALL_EXPRESSION:
				sequence_BaseExpression(context, (CallExpression) semanticObject); 
				return; 
			case ModelPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ModelPackage.DIFFERENCE_OPERATOR:
				sequence_SumDiffOperator(context, (DifferenceOperator) semanticObject); 
				return; 
			case ModelPackage.DIS_EQUAL_OPERATOR:
				sequence_RelationOperator(context, (DisEqualOperator) semanticObject); 
				return; 
			case ModelPackage.DIVISION_OPERATOR:
				sequence_MulDivOperator(context, (DivisionOperator) semanticObject); 
				return; 
			case ModelPackage.EQUAL_OPERATOR:
				sequence_RelationOperator(context, (EqualOperator) semanticObject); 
				return; 
			case ModelPackage.FALSE_LITERAL:
				sequence_BaseExpression(context, (FalseLiteral) semanticObject); 
				return; 
			case ModelPackage.FRACTION_OF:
				sequence_FractionOf(context, (FractionOf) semanticObject); 
				return; 
			case ModelPackage.GREATER_OPERATOR:
				sequence_RelationOperator(context, (GreaterOperator) semanticObject); 
				return; 
			case ModelPackage.GREATER_OR_EQUAL_OPERATOR:
				sequence_RelationOperator(context, (GreaterOrEqualOperator) semanticObject); 
				return; 
			case ModelPackage.IF_THEN_ELSE_EXPRESSION:
				sequence_IfThenElseExpression(context, (IfThenElseExpression) semanticObject); 
				return; 
			case ModelPackage.LESS_OPERATOR:
				sequence_RelationOperator(context, (LessOperator) semanticObject); 
				return; 
			case ModelPackage.LESS_OR_EQUAL_OPERATOR:
				sequence_RelationOperator(context, (LessOrEqualOperator) semanticObject); 
				return; 
			case ModelPackage.MACRO:
				sequence_Macro(context, (Macro) semanticObject); 
				return; 
			case ModelPackage.MAX_EXPRESSION:
				sequence_BaseExpression(context, (MaxExpression) semanticObject); 
				return; 
			case ModelPackage.MEASURE:
				sequence_Measure(context, (Measure) semanticObject); 
				return; 
			case ModelPackage.MIN_EXPRESSION:
				sequence_BaseExpression(context, (MinExpression) semanticObject); 
				return; 
			case ModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModelPackage.MODULO_EXPRESSION:
				sequence_ModuloExpression(context, (ModuloExpression) semanticObject); 
				return; 
			case ModelPackage.MUL_DIV_EXPRESSION:
				sequence_MulDivExpression(context, (MulDivExpression) semanticObject); 
				return; 
			case ModelPackage.MULTIPLICATION_OPERATOR:
				sequence_MulDivOperator(context, (MultiplicationOperator) semanticObject); 
				return; 
			case ModelPackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case ModelPackage.NEGATION_EXPRESSION:
				sequence_BaseExpression(context, (NegationExpression) semanticObject); 
				return; 
			case ModelPackage.NOT_EXPRESSION:
				sequence_BaseExpression(context, (NotExpression) semanticObject); 
				return; 
			case ModelPackage.NUM_EXPRESSION:
				sequence_NumExpression(context, (NumExpression) semanticObject); 
				return; 
			case ModelPackage.NUMBER_OF:
				sequence_NumberOf(context, (NumberOf) semanticObject); 
				return; 
			case ModelPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case ModelPackage.POPULATION:
				sequence_Population(context, (Population) semanticObject); 
				return; 
			case ModelPackage.RELATION_EXPRESSION:
				sequence_RelationExpression(context, (RelationExpression) semanticObject); 
				return; 
			case ModelPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case ModelPackage.SPECIES:
				sequence_Species(context, (Species) semanticObject); 
				return; 
			case ModelPackage.SUM_DIFF_EXPRESSION:
				sequence_SumDiffExpression(context, (SumDiffExpression) semanticObject); 
				return; 
			case ModelPackage.SUM_OPERATOR:
				sequence_SumDiffOperator(context, (SumOperator) semanticObject); 
				return; 
			case ModelPackage.SYSTEM:
				sequence_System(context, (quasylab.sibilla.lang.pm.model.System) semanticObject); 
				return; 
			case ModelPackage.TRUE_LITERAL:
				sequence_BaseExpression(context, (TrueLiteral) semanticObject); 
				return; 
			case ModelPackage.ZERO_DIVISION_OPERATOR:
				sequence_MulDivOperator(context, (ZeroDivisionOperator) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     RelationExpression returns AndExpression
	 *     RelationExpression.RelationExpression_1_0 returns AndExpression
	 *     MulDivExpression returns AndExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns AndExpression
	 *     SumDiffExpression returns AndExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns AndExpression
	 *     ModuloExpression returns AndExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns AndExpression
	 *     BaseExpression returns AndExpression
	 *     IfThenElseExpression returns AndExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=RelationExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightRelationExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CallExpression
	 *     OrExpression returns CallExpression
	 *     OrExpression.OrExpression_1_0 returns CallExpression
	 *     AndExpression returns CallExpression
	 *     AndExpression.AndExpression_1_0 returns CallExpression
	 *     RelationExpression returns CallExpression
	 *     RelationExpression.RelationExpression_1_0 returns CallExpression
	 *     MulDivExpression returns CallExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns CallExpression
	 *     SumDiffExpression returns CallExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns CallExpression
	 *     ModuloExpression returns CallExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns CallExpression
	 *     BaseExpression returns CallExpression
	 *     IfThenElseExpression returns CallExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns CallExpression
	 *
	 * Constraint:
	 *     symbol=[ReferenceableElement|ID]
	 */
	protected void sequence_BaseExpression(ISerializationContext context, CallExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.CALL_EXPRESSION__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.CALL_EXPRESSION__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExpressionAccess().getSymbolReferenceableElementIDTerminalRuleCall_8_1_0_1(), semanticObject.eGet(ModelPackage.Literals.CALL_EXPRESSION__SYMBOL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FalseLiteral
	 *     OrExpression returns FalseLiteral
	 *     OrExpression.OrExpression_1_0 returns FalseLiteral
	 *     AndExpression returns FalseLiteral
	 *     AndExpression.AndExpression_1_0 returns FalseLiteral
	 *     RelationExpression returns FalseLiteral
	 *     RelationExpression.RelationExpression_1_0 returns FalseLiteral
	 *     MulDivExpression returns FalseLiteral
	 *     MulDivExpression.MulDivExpression_1_0 returns FalseLiteral
	 *     SumDiffExpression returns FalseLiteral
	 *     SumDiffExpression.SumDiffExpression_1_0 returns FalseLiteral
	 *     ModuloExpression returns FalseLiteral
	 *     ModuloExpression.ModuloExpression_1_0 returns FalseLiteral
	 *     BaseExpression returns FalseLiteral
	 *     IfThenElseExpression returns FalseLiteral
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns FalseLiteral
	 *
	 * Constraint:
	 *     {FalseLiteral}
	 */
	protected void sequence_BaseExpression(ISerializationContext context, FalseLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MaxExpression
	 *     OrExpression returns MaxExpression
	 *     OrExpression.OrExpression_1_0 returns MaxExpression
	 *     AndExpression returns MaxExpression
	 *     AndExpression.AndExpression_1_0 returns MaxExpression
	 *     RelationExpression returns MaxExpression
	 *     RelationExpression.RelationExpression_1_0 returns MaxExpression
	 *     MulDivExpression returns MaxExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns MaxExpression
	 *     SumDiffExpression returns MaxExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns MaxExpression
	 *     ModuloExpression returns MaxExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns MaxExpression
	 *     BaseExpression returns MaxExpression
	 *     IfThenElseExpression returns MaxExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns MaxExpression
	 *
	 * Constraint:
	 *     (args+=Expression args+=Expression+)
	 */
	protected void sequence_BaseExpression(ISerializationContext context, MaxExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinExpression
	 *     OrExpression returns MinExpression
	 *     OrExpression.OrExpression_1_0 returns MinExpression
	 *     AndExpression returns MinExpression
	 *     AndExpression.AndExpression_1_0 returns MinExpression
	 *     RelationExpression returns MinExpression
	 *     RelationExpression.RelationExpression_1_0 returns MinExpression
	 *     MulDivExpression returns MinExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns MinExpression
	 *     SumDiffExpression returns MinExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns MinExpression
	 *     ModuloExpression returns MinExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns MinExpression
	 *     BaseExpression returns MinExpression
	 *     IfThenElseExpression returns MinExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns MinExpression
	 *
	 * Constraint:
	 *     (args+=Expression args+=Expression+)
	 */
	protected void sequence_BaseExpression(ISerializationContext context, MinExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NegationExpression
	 *     OrExpression returns NegationExpression
	 *     OrExpression.OrExpression_1_0 returns NegationExpression
	 *     AndExpression returns NegationExpression
	 *     AndExpression.AndExpression_1_0 returns NegationExpression
	 *     RelationExpression returns NegationExpression
	 *     RelationExpression.RelationExpression_1_0 returns NegationExpression
	 *     MulDivExpression returns NegationExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns NegationExpression
	 *     SumDiffExpression returns NegationExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns NegationExpression
	 *     ModuloExpression returns NegationExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns NegationExpression
	 *     BaseExpression returns NegationExpression
	 *     IfThenElseExpression returns NegationExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns NegationExpression
	 *
	 * Constraint:
	 *     argument=BaseExpression
	 */
	protected void sequence_BaseExpression(ISerializationContext context, NegationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NEGATION_EXPRESSION__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NEGATION_EXPRESSION__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExpressionAccess().getArgumentBaseExpressionParserRuleCall_7_2_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     RelationExpression returns NotExpression
	 *     RelationExpression.RelationExpression_1_0 returns NotExpression
	 *     MulDivExpression returns NotExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns NotExpression
	 *     SumDiffExpression returns NotExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns NotExpression
	 *     ModuloExpression returns NotExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns NotExpression
	 *     BaseExpression returns NotExpression
	 *     IfThenElseExpression returns NotExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns NotExpression
	 *
	 * Constraint:
	 *     argument=BaseExpression
	 */
	protected void sequence_BaseExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NOT_EXPRESSION__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NOT_EXPRESSION__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExpressionAccess().getArgumentBaseExpressionParserRuleCall_3_2_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TrueLiteral
	 *     OrExpression returns TrueLiteral
	 *     OrExpression.OrExpression_1_0 returns TrueLiteral
	 *     AndExpression returns TrueLiteral
	 *     AndExpression.AndExpression_1_0 returns TrueLiteral
	 *     RelationExpression returns TrueLiteral
	 *     RelationExpression.RelationExpression_1_0 returns TrueLiteral
	 *     MulDivExpression returns TrueLiteral
	 *     MulDivExpression.MulDivExpression_1_0 returns TrueLiteral
	 *     SumDiffExpression returns TrueLiteral
	 *     SumDiffExpression.SumDiffExpression_1_0 returns TrueLiteral
	 *     ModuloExpression returns TrueLiteral
	 *     ModuloExpression.ModuloExpression_1_0 returns TrueLiteral
	 *     BaseExpression returns TrueLiteral
	 *     IfThenElseExpression returns TrueLiteral
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns TrueLiteral
	 *
	 * Constraint:
	 *     {TrueLiteral}
	 */
	protected void sequence_BaseExpression(ISerializationContext context, TrueLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Constant
	 *     Constant returns Constant
	 *     ReferenceableElement returns Constant
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FractionOf
	 *     OrExpression returns FractionOf
	 *     OrExpression.OrExpression_1_0 returns FractionOf
	 *     AndExpression returns FractionOf
	 *     AndExpression.AndExpression_1_0 returns FractionOf
	 *     RelationExpression returns FractionOf
	 *     RelationExpression.RelationExpression_1_0 returns FractionOf
	 *     MulDivExpression returns FractionOf
	 *     MulDivExpression.MulDivExpression_1_0 returns FractionOf
	 *     SumDiffExpression returns FractionOf
	 *     SumDiffExpression.SumDiffExpression_1_0 returns FractionOf
	 *     ModuloExpression returns FractionOf
	 *     ModuloExpression.ModuloExpression_1_0 returns FractionOf
	 *     BaseExpression returns FractionOf
	 *     IfThenElseExpression returns FractionOf
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns FractionOf
	 *     FractionOf returns FractionOf
	 *
	 * Constraint:
	 *     agent=[Species|ID]
	 */
	protected void sequence_FractionOf(ISerializationContext context, FractionOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.FRACTION_OF__AGENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.FRACTION_OF__AGENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFractionOfAccess().getAgentSpeciesIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ModelPackage.Literals.FRACTION_OF__AGENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfThenElseExpression
	 *     OrExpression returns IfThenElseExpression
	 *     OrExpression.OrExpression_1_0 returns IfThenElseExpression
	 *     AndExpression returns IfThenElseExpression
	 *     AndExpression.AndExpression_1_0 returns IfThenElseExpression
	 *     RelationExpression returns IfThenElseExpression
	 *     RelationExpression.RelationExpression_1_0 returns IfThenElseExpression
	 *     MulDivExpression returns IfThenElseExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns IfThenElseExpression
	 *     SumDiffExpression returns IfThenElseExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns IfThenElseExpression
	 *     ModuloExpression returns IfThenElseExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns IfThenElseExpression
	 *     BaseExpression returns IfThenElseExpression
	 *     IfThenElseExpression returns IfThenElseExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns IfThenElseExpression
	 *
	 * Constraint:
	 *     (guard=IfThenElseExpression_IfThenElseExpression_2_0 ifBranch=Expression elseBranch=Expression)
	 */
	protected void sequence_IfThenElseExpression(ISerializationContext context, IfThenElseExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_THEN_ELSE_EXPRESSION__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_THEN_ELSE_EXPRESSION__GUARD));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_THEN_ELSE_EXPRESSION__IF_BRANCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_THEN_ELSE_EXPRESSION__IF_BRANCH));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_THEN_ELSE_EXPRESSION__ELSE_BRANCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_THEN_ELSE_EXPRESSION__ELSE_BRANCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfThenElseExpressionAccess().getIfThenElseExpressionGuardAction_2_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getIfThenElseExpressionAccess().getIfBranchExpressionParserRuleCall_2_2_0(), semanticObject.getIfBranch());
		feeder.accept(grammarAccess.getIfThenElseExpressionAccess().getElseBranchExpressionParserRuleCall_2_4_0(), semanticObject.getElseBranch());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Macro
	 *     Macro returns Macro
	 *     ReferenceableElement returns Macro
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_Macro(ISerializationContext context, Macro semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MACRO__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MACRO__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMacroAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMacroAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Measure
	 *     Measure returns Measure
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_Measure(ISerializationContext context, Measure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MEASURE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MEASURE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeasureAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMeasureAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=Element+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ModuloExpression
	 *     OrExpression returns ModuloExpression
	 *     OrExpression.OrExpression_1_0 returns ModuloExpression
	 *     AndExpression returns ModuloExpression
	 *     AndExpression.AndExpression_1_0 returns ModuloExpression
	 *     RelationExpression returns ModuloExpression
	 *     RelationExpression.RelationExpression_1_0 returns ModuloExpression
	 *     MulDivExpression returns ModuloExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns ModuloExpression
	 *     SumDiffExpression returns ModuloExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns ModuloExpression
	 *     ModuloExpression returns ModuloExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns ModuloExpression
	 *     BaseExpression returns ModuloExpression
	 *     IfThenElseExpression returns ModuloExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns ModuloExpression
	 *
	 * Constraint:
	 *     (left=ModuloExpression_ModuloExpression_1_0 right=BaseExpression)
	 */
	protected void sequence_ModuloExpression(ISerializationContext context, ModuloExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MODULO_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MODULO_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MODULO_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MODULO_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuloExpressionAccess().getModuloExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getModuloExpressionAccess().getRightBaseExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulDivExpression
	 *     OrExpression returns MulDivExpression
	 *     OrExpression.OrExpression_1_0 returns MulDivExpression
	 *     AndExpression returns MulDivExpression
	 *     AndExpression.AndExpression_1_0 returns MulDivExpression
	 *     RelationExpression returns MulDivExpression
	 *     RelationExpression.RelationExpression_1_0 returns MulDivExpression
	 *     MulDivExpression returns MulDivExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns MulDivExpression
	 *     SumDiffExpression returns MulDivExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns MulDivExpression
	 *     ModuloExpression returns MulDivExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns MulDivExpression
	 *     BaseExpression returns MulDivExpression
	 *     IfThenElseExpression returns MulDivExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns MulDivExpression
	 *
	 * Constraint:
	 *     (left=MulDivExpression_MulDivExpression_1_0 op=MulDivOperator right=ModuloExpression)
	 */
	protected void sequence_MulDivExpression(ISerializationContext context, MulDivExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MUL_DIV_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MUL_DIV_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MUL_DIV_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MUL_DIV_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MUL_DIV_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MUL_DIV_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivExpressionAccess().getMulDivExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivExpressionAccess().getOpMulDivOperatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMulDivExpressionAccess().getRightModuloExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MulDivOperator returns DivisionOperator
	 *
	 * Constraint:
	 *     {DivisionOperator}
	 */
	protected void sequence_MulDivOperator(ISerializationContext context, DivisionOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MulDivOperator returns MultiplicationOperator
	 *
	 * Constraint:
	 *     {MultiplicationOperator}
	 */
	protected void sequence_MulDivOperator(ISerializationContext context, MultiplicationOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MulDivOperator returns ZeroDivisionOperator
	 *
	 * Constraint:
	 *     {ZeroDivisionOperator}
	 */
	protected void sequence_MulDivOperator(ISerializationContext context, ZeroDivisionOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns Multiplicity
	 *
	 * Constraint:
	 *     (species=[Species|ID] size=Expression?)
	 */
	protected void sequence_Multiplicity(ISerializationContext context, Multiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumExpression
	 *     OrExpression returns NumExpression
	 *     OrExpression.OrExpression_1_0 returns NumExpression
	 *     AndExpression returns NumExpression
	 *     AndExpression.AndExpression_1_0 returns NumExpression
	 *     RelationExpression returns NumExpression
	 *     RelationExpression.RelationExpression_1_0 returns NumExpression
	 *     MulDivExpression returns NumExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns NumExpression
	 *     SumDiffExpression returns NumExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns NumExpression
	 *     ModuloExpression returns NumExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns NumExpression
	 *     BaseExpression returns NumExpression
	 *     IfThenElseExpression returns NumExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns NumExpression
	 *     NumExpression returns NumExpression
	 *
	 * Constraint:
	 *     (((intPart=INT (isReal?='.' decimalPart=INT?)?) | (isReal?='.' decimalPart=INT)) exponent=INT?)
	 */
	protected void sequence_NumExpression(ISerializationContext context, NumExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberOf
	 *     OrExpression returns NumberOf
	 *     OrExpression.OrExpression_1_0 returns NumberOf
	 *     AndExpression returns NumberOf
	 *     AndExpression.AndExpression_1_0 returns NumberOf
	 *     RelationExpression returns NumberOf
	 *     RelationExpression.RelationExpression_1_0 returns NumberOf
	 *     MulDivExpression returns NumberOf
	 *     MulDivExpression.MulDivExpression_1_0 returns NumberOf
	 *     SumDiffExpression returns NumberOf
	 *     SumDiffExpression.SumDiffExpression_1_0 returns NumberOf
	 *     ModuloExpression returns NumberOf
	 *     ModuloExpression.ModuloExpression_1_0 returns NumberOf
	 *     BaseExpression returns NumberOf
	 *     IfThenElseExpression returns NumberOf
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns NumberOf
	 *     NumberOf returns NumberOf
	 *
	 * Constraint:
	 *     agent=[Species|ID]
	 */
	protected void sequence_NumberOf(ISerializationContext context, NumberOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NUMBER_OF__AGENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NUMBER_OF__AGENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberOfAccess().getAgentSpeciesIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ModelPackage.Literals.NUMBER_OF__AGENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     RelationExpression returns OrExpression
	 *     RelationExpression.RelationExpression_1_0 returns OrExpression
	 *     MulDivExpression returns OrExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns OrExpression
	 *     SumDiffExpression returns OrExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns OrExpression
	 *     ModuloExpression returns OrExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns OrExpression
	 *     BaseExpression returns OrExpression
	 *     IfThenElseExpression returns OrExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Population returns Population
	 *
	 * Constraint:
	 *     (population+=Multiplicity population+=Multiplicity*)?
	 */
	protected void sequence_Population(ISerializationContext context, Population semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelationExpression
	 *     OrExpression returns RelationExpression
	 *     OrExpression.OrExpression_1_0 returns RelationExpression
	 *     AndExpression returns RelationExpression
	 *     AndExpression.AndExpression_1_0 returns RelationExpression
	 *     RelationExpression returns RelationExpression
	 *     RelationExpression.RelationExpression_1_0 returns RelationExpression
	 *     MulDivExpression returns RelationExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns RelationExpression
	 *     SumDiffExpression returns RelationExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns RelationExpression
	 *     ModuloExpression returns RelationExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns RelationExpression
	 *     BaseExpression returns RelationExpression
	 *     IfThenElseExpression returns RelationExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns RelationExpression
	 *
	 * Constraint:
	 *     (left=RelationExpression_RelationExpression_1_0 op=RelationOperator right=SumDiffExpression)
	 */
	protected void sequence_RelationExpression(ISerializationContext context, RelationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATION_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATION_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATION_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATION_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATION_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATION_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRelationExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getOpRelationOperatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRightSumDiffExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationOperator returns DisEqualOperator
	 *
	 * Constraint:
	 *     {DisEqualOperator}
	 */
	protected void sequence_RelationOperator(ISerializationContext context, DisEqualOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationOperator returns EqualOperator
	 *
	 * Constraint:
	 *     {EqualOperator}
	 */
	protected void sequence_RelationOperator(ISerializationContext context, EqualOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationOperator returns GreaterOperator
	 *
	 * Constraint:
	 *     {GreaterOperator}
	 */
	protected void sequence_RelationOperator(ISerializationContext context, GreaterOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationOperator returns GreaterOrEqualOperator
	 *
	 * Constraint:
	 *     {GreaterOrEqualOperator}
	 */
	protected void sequence_RelationOperator(ISerializationContext context, GreaterOrEqualOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationOperator returns LessOperator
	 *
	 * Constraint:
	 *     {LessOperator}
	 */
	protected void sequence_RelationOperator(ISerializationContext context, LessOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationOperator returns LessOrEqualOperator
	 *
	 * Constraint:
	 *     {LessOrEqualOperator}
	 */
	protected void sequence_RelationOperator(ISerializationContext context, LessOrEqualOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Rule
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID guard=Expression? pre=Population rate=Expression post=Population)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Species
	 *     SpeciesDeclaration returns Species
	 *     Species returns Species
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Species(ISerializationContext context, Species semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpeciesAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SumDiffExpression
	 *     OrExpression returns SumDiffExpression
	 *     OrExpression.OrExpression_1_0 returns SumDiffExpression
	 *     AndExpression returns SumDiffExpression
	 *     AndExpression.AndExpression_1_0 returns SumDiffExpression
	 *     RelationExpression returns SumDiffExpression
	 *     RelationExpression.RelationExpression_1_0 returns SumDiffExpression
	 *     MulDivExpression returns SumDiffExpression
	 *     MulDivExpression.MulDivExpression_1_0 returns SumDiffExpression
	 *     SumDiffExpression returns SumDiffExpression
	 *     SumDiffExpression.SumDiffExpression_1_0 returns SumDiffExpression
	 *     ModuloExpression returns SumDiffExpression
	 *     ModuloExpression.ModuloExpression_1_0 returns SumDiffExpression
	 *     BaseExpression returns SumDiffExpression
	 *     IfThenElseExpression returns SumDiffExpression
	 *     IfThenElseExpression.IfThenElseExpression_2_0 returns SumDiffExpression
	 *
	 * Constraint:
	 *     (left=SumDiffExpression_SumDiffExpression_1_0 op=SumDiffOperator right=MulDivExpression)
	 */
	protected void sequence_SumDiffExpression(ISerializationContext context, SumDiffExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.SUM_DIFF_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.SUM_DIFF_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.SUM_DIFF_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.SUM_DIFF_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.SUM_DIFF_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.SUM_DIFF_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumDiffExpressionAccess().getSumDiffExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSumDiffExpressionAccess().getOpSumDiffOperatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getSumDiffExpressionAccess().getRightMulDivExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SumDiffOperator returns DifferenceOperator
	 *
	 * Constraint:
	 *     {DifferenceOperator}
	 */
	protected void sequence_SumDiffOperator(ISerializationContext context, DifferenceOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SumDiffOperator returns SumOperator
	 *
	 * Constraint:
	 *     {SumOperator}
	 */
	protected void sequence_SumDiffOperator(ISerializationContext context, SumOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns System
	 *     System returns System
	 *
	 * Constraint:
	 *     (name=ID population=Population)
	 */
	protected void sequence_System(ISerializationContext context, quasylab.sibilla.lang.pm.model.System semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.SYSTEM__POPULATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.SYSTEM__POPULATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSystemAccess().getPopulationPopulationParserRuleCall_3_0(), semanticObject.getPopulation());
		feeder.finish();
	}
	
	
}
