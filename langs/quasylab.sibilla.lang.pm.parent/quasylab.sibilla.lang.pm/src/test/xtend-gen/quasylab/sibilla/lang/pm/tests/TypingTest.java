/*
 * Sibilla:  a Java framework designed to support analysis of Collective
 * Adaptive Systems.
 *
 * Copyright (C) 2020.
 *
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *            http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 */

/**
 * generated by Xtext 2.17.0
 */
package quasylab.sibilla.lang.pm.tests;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import quasylab.sibilla.lang.pm.model.Constant;
import quasylab.sibilla.lang.pm.model.Expression;
import quasylab.sibilla.lang.pm.model.Model;
import quasylab.sibilla.lang.pm.tests.ModelInjectorProvider;
import quasylab.sibilla.lang.pm.validation.ExpressionType;
import quasylab.sibilla.lang.pm.validation.ExpressionTypeInference;

@ExtendWith(InjectionExtension.class)
@InjectWith(ModelInjectorProvider.class)
@SuppressWarnings("all")
public class TypingTest {
  @Inject
  @Extension
  private ParseHelper<Model> _parseHelper;
  
  @Inject
  @Extension
  private ExpressionTypeInference _expressionTypeInference;
  
  @Test
  public void intValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10");
    this.assertContantType(_builder, ExpressionType.INTEGER);
  }
  
  @Test
  public void intValueWithExponent() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10E2");
    this.assertContantType(_builder, ExpressionType.INTEGER);
  }
  
  @Test
  public void realValueNoFraction() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10.");
    this.assertContantType(_builder, ExpressionType.DOUBLE);
  }
  
  @Test
  public void realValueNoInt() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(".10");
    this.assertContantType(_builder, ExpressionType.DOUBLE);
  }
  
  @Test
  public void realValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("1.10");
    this.assertContantType(_builder, ExpressionType.DOUBLE);
  }
  
  @Test
  public void realValueWithExponent() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10.0E2");
    this.assertContantType(_builder, ExpressionType.DOUBLE);
  }
  
  @Test
  public void trueValue() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("true");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void orExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("true | false");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void andExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("true & false");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void equalExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 == 5");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void lessExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 < 5");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void lessOrEqualExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 <= 5");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void greaterExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 > 5");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void greaterOrEqualExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 > 5");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void notEqualExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 != 5");
    this.assertContantType(_builder, ExpressionType.BOOLEAN);
  }
  
  @Test
  public void intSumExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 + 5");
    this.assertContantType(_builder, ExpressionType.INTEGER);
  }
  
  @Test
  public void realSumExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 + 5.0");
    this.assertContantType(_builder, ExpressionType.DOUBLE);
  }
  
  @Test
  public void errorSumExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("10 + true");
    this.assertContantType(_builder, ExpressionType.ERROR);
  }
  
  @Test
  public void ifThenElseIntExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(true?10:11)");
    this.assertContantType(_builder, ExpressionType.INTEGER);
  }
  
  @Test
  public void ifThenElseRealExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(true?10.0:11)");
    this.assertContantType(_builder, ExpressionType.DOUBLE);
  }
  
  @Test
  public void ifThenElseErrorExpression() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(true?true:11)");
    this.assertContantType(_builder, ExpressionType.ERROR);
  }
  
  public void assertContantType(final CharSequence input, final ExpressionType expectedType) {
    try {
      this.assertType(IterableExtensions.<Constant>last(Iterables.<Constant>filter(this._parseHelper.parse((("const test = " + input) + ";")).getElements(), Constant.class)).getValue(), expectedType);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void assertType(final Expression e, final ExpressionType expectedType) {
    Assertions.assertSame(expectedType, this._expressionTypeInference.inferType(e));
  }
}
