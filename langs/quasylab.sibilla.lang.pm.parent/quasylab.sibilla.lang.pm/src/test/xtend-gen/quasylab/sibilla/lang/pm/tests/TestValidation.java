/**
 * generated by Xtext 2.17.0
 */
package quasylab.sibilla.lang.pm.tests;

import com.google.inject.Inject;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.testing.validation.ValidationTestHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import quasylab.sibilla.lang.pm.model.Model;
import quasylab.sibilla.lang.pm.model.ModelPackage;
import quasylab.sibilla.lang.pm.tests.ModelInjectorProvider;
import quasylab.sibilla.lang.pm.validation.ExpressionType;
import quasylab.sibilla.lang.pm.validation.ModelValidator;

@ExtendWith(InjectionExtension.class)
@InjectWith(ModelInjectorProvider.class)
@SuppressWarnings("all")
public class TestValidation {
  @Inject
  @Extension
  private ParseHelper<Model> _parseHelper;
  
  @Inject
  @Extension
  private ValidationTestHelper _validationTestHelper;
  
  @Test
  public void relationNoNumberTypeLeft() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = true<10;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getRelationExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void relationNoNumberTypeRight() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 10<true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getRelationExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void relationNoNumberTypeLeftRight() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false<true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getRelationExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void orWrongLeftType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 1||false;");
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getOrExpression(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void orWrongRightType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false||1;");
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getOrExpression(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void andWrongLeftType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 1&&false;");
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getAndExpression(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void andWrongRightType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false&&1;");
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getAndExpression(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void moduloWrongLeftType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 1%false;");
      this.assertNoInteger(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getModuloExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void moduloWrongRightType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false%1;");
      this.assertNoInteger(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getModuloExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void divNoNumberTypeRight() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 10/true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMulDivExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void divNoNumberTypeLeft() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false/10;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMulDivExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void mulNoNumberTypeRight() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 10*true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMulDivExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void mulNoNumberTypeLeft() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false*10;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMulDivExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void sumNoNumberTypeRight() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 10+true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getSumDiffExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void sumNoNumberTypeLeft() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false+10;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getSumDiffExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void diffNoNumberTypeRight() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = 10-true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getSumDiffExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void diffNoNumberTypeLeft() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = false-10;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getSumDiffExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void notWrongArgumentType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = !1;");
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getNotExpression(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void ifThenElseWrongGuardType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = (1?1:2);");
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getIfThenElseExpression(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void ifThenElseUncompatibleTypes() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = (true?true:2);");
      this.assertIncompatibleType(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getIfThenElseExpression(), ExpressionType.BOOLEAN, ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void negationWrongArgumentType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = -true;");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getNegationExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void minWrongArgumentType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = min( 1 , true );");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMinExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void maxWrongArgumentType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const test = max( 1 , true );");
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMaxExpression(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void ruleGuardWrongType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("rule test[1] = A|B -[ 1.0 ]-> A|A;");
      _builder.newLine();
      this.assertNoBoolean(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getRule(), ExpressionType.INTEGER);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void ruleRateWrongType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("rule test = A|B -[ true ]-> A|A;");
      _builder.newLine();
      this.assertNotNumber(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getRule(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void multiplicitySizeWrongType() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("rule test = A[true] -[ 1.0 ]-> B;");
      _builder.newLine();
      this.assertNoInteger(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getMultiplicity(), ExpressionType.BOOLEAN);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void dynamicFractionExpressionInConstant() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("const test = %A;");
      _builder.newLine();
      this._validationTestHelper.assertError(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getFractionOf(), 
        ModelValidator.ILLEGAL_POPULATION_EXPRESSION, 
        ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void dynamicCouningExpressionInConstant() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("const test = #A;");
      _builder.newLine();
      this._validationTestHelper.assertError(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getNumberOf(), 
        ModelValidator.ILLEGAL_POPULATION_EXPRESSION, 
        ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void macroWithCountingExpression() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("macro test = #A;");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void macroWithFractionExpression() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("macro test = %A;");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void noMacroInConstant() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("macro aMacro = #A;");
      _builder.newLine();
      _builder.append("const test = aMacro;");
      _builder.newLine();
      this._validationTestHelper.assertError(this._parseHelper.parse(_builder), ModelPackage.eINSTANCE.getCallExpression(), 
        ModelValidator.ILLEGAL_POPULATION_EXPRESSION, 
        ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void correctConstReference() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("species A;");
      _builder.newLine();
      _builder.append("species B;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("const const1 = 1;");
      _builder.newLine();
      _builder.append("const const2 = const1+1;");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRecursiveConstants() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const constA = constB;");
      _builder.newLine();
      _builder.append("const constB = constC;");
      _builder.newLine();
      _builder.append("const constC = constA;");
      _builder.newLine();
      this._validationTestHelper.assertError(this._parseHelper.parse(_builder), 
        ModelPackage.eINSTANCE.getConstant(), 
        ModelValidator.RECURSIVE_DECLARATION, 
        ModelValidator.recursiveDeclarationMessage("constA"));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNoRecursiveConstants() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const constA = constB;");
      _builder.newLine();
      _builder.append("const constB = constC;");
      _builder.newLine();
      _builder.append("const constC = 1.0;");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testRecursiveMacros() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("macro macroA = macroB;");
      _builder.newLine();
      _builder.append("macro macroB = macroC;");
      _builder.newLine();
      _builder.append("macro macroC = macroA;");
      _builder.newLine();
      this._validationTestHelper.assertError(this._parseHelper.parse(_builder), 
        ModelPackage.eINSTANCE.getMacro(), 
        ModelValidator.RECURSIVE_DECLARATION, 
        ModelValidator.recursiveDeclarationMessage("macroA"));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testNoRecursiveMacros() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("macro macroA = macroB;");
      _builder.newLine();
      _builder.append("macro macroB = macroC;");
      _builder.newLine();
      _builder.append("macro macroC = 1.0;");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void assertIncompatibleType(final Model m, final EClass objectType, final ExpressionType exptected, final ExpressionType actual) {
    this._validationTestHelper.assertError(m, objectType, ModelValidator.INCOMPATIBLE_TYPES, ModelValidator.incompatibleTypesMessage(exptected, actual));
  }
  
  private void assertNotNumber(final Model m, final EClass objectType, final ExpressionType actual) {
    this._validationTestHelper.assertError(m, objectType, ModelValidator.TYPE_MISMATCH, ModelValidator.numberTypeExpected(actual));
  }
  
  private void assertNoBoolean(final Model m, final EClass objectType, final ExpressionType actual) {
    this._validationTestHelper.assertError(m, objectType, ModelValidator.TYPE_MISMATCH, ModelValidator.booleanTypeExpected(actual));
  }
  
  private void assertNoInteger(final Model m, final EClass objectType, final ExpressionType actual) {
    this._validationTestHelper.assertError(m, objectType, ModelValidator.TYPE_MISMATCH, ModelValidator.integerTypeExpected(actual));
  }
}
